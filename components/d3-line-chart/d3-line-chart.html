<!-- imports -->
<link rel='import' href='../polymer/polymer.html'>
<link rel='import' href='../core-icons/core-icons.html'>
<link rel='import' href='../core-icon/core-icon.html'>
<link rel='import' href='../lib-d3/lib-d3.html'>
<link rel='import' href='../px10-node-resize-detector/px10-element-resize-detector.html'>

<!--
Responsive and configurable Polymer element for line charts based on D3.js library.

#### Basic usage example
    <d3-line-chart data='{{ [[1,2],[2,4],[3,8],[4,16]] }}' flex></d3-line-chart>

#### More advanced configuration
(x time scale with 4 ticks and label, y pow scale with exponent 0.10, responsive to size change)

    <d3-line-chart flex data='{{ [[Date1,1],[Date2,2],[Date3,3]] }}'
      title='Test chart'
      axes='{{ [{ name: 'xAxis', scale: 'time', ticks: 4, label: 'Time' },
        { name: 'yAxis', scale: { type: 'pow', exponent: 0.10 } }] }}'
      responsive
    ></d3-line-chart>

For more advanced configuration examples please look into demo source.

#### Styling
  - set chart's width & height by css or add it to layout (you can use flex attribute on it)
  - chart is ready for external styling and currently features one ready theme (enable theme with class='massive')

#### Comments
  - after changes inside specific axis or metadata configuration you will need to trigger prepare() for changes to take place
  - you need to set chart's dimensions (at least min width/height) or put it into layout for it to display

#### Roadmap for next releases
  - save to file
  - configurable lines and colors
  - hover series details
  - d3-chart element with other chart types

#### Licence
[MIT License](http://opensource.org/licenses/MIT) © [Błażej Wolańczyk](https://github.com/Junikorn)

@element d3-line-chart
@demo http://polymoar.github.io/components/d3-line-chart/demo.html
@blurb Responsive and configurable Polymer element for line charts based on D3.js library.
@status alpha
@homepage https://github.com/Polymoar/d3-line-chart
-->
<polymer-element name='d3-line-chart'>
  <template>
    <link rel='stylesheet' href='d3-line-chart.css'>
    <div id='container' fit layout vertical>
      <template if='{{ name }}'>
        <div id='title'>{{ name }}</div>
      </template>
      <div flex layout vertical?='{{ vertical }}' horizontal?='{{ !vertical }}'>
        <div id='chart' flex>
          <svg id='paper'></svg>
          <template if='{{ responsive }}'>
            <px10-element-resize-detector target='{{ }}' on-resize='{{ prepare }}'></px10-element-resize-detector>
          </template>
        </div>
        <template if='{{ legend }}'>
          <div id='legend' vertical?='{{ vertical }}'>
            <template repeat='{{ dataset in metadata }}'>
              <div class='entry'>
                <core-icon icon='label'></core-icon>
                <span>{{ dataset.label }}</span>
              </div>
            </template>
          </div>
        </template>
      </div>
    </div>
  </template>
  <script>
    (function(){
      /* TODO:
       * - configurable svg (line & axis colors and widths etc) ?
       * - refactor everything :D
       */
      Polymer({

        //published attributes
        publish: {
          /**
           * Chart title, if not set the title section is hidden
           *
           * @attribute name
           * @type String
           * @default null
           */
          name: null,
          /**
           * Array containing axes configuration. Each axis configuration is an object as described below:
           * ```
           * [{
           *    name: String (required)
           *    label: String
           *    scale: String or Object - scale of axis, defaults to scale attribute value
           *    interpolation: String - mode of line interpolation for axis, defaults to interpolation attribute value
           *    ticks: Number or Object
           *      Number - approximate number of ticks to display
           *      Object - ticks configuration, each property will be argument of call to axis method with the same name
           * }, ...]
           * ```
           * See D3.js documentation for [available axis methods](https://github.com/mbostock/d3/wiki/SVG-Axes#ticks)
           *
           * Note that x axis configuration should be first object in array and chart can display at most 3 axes [x, y1, y2].
           *
           * @attribute axes
           * @type Array
           * @default [{ name: 'xAxis' }, { name: 'yAxis' }]
           */
          axes: null,
          /**
           * Array containing series configuration. Each series configuration is an object as described below:
           * ```
           * [{
           *    label: String (recommended if `legend` attribute set)
           *    axis: String - name of axis the series belongs to, if not set defaults to 'yAxis'
           *    interpolation: String - mode of line interpolation for series, defaults to axis.interpolation
           *    x: function(record) - function getting x from record
           *    y: function(record) - function getting y from record (required if `data` contains objects)
           * }, ...]
           * ```
           * Note that first element of array is drawn with lowest 'z-index'
           *
           * @attribute metadata
           * @type Array
           * @default [{ axis: 'yAxis' }]
           */
          metadata: null,
          /**
           * Array of records in form of:
           *  - Objects (requires usage of metadata.y and recommended metadata.x)
           *  - Arrays (does not require x y getters but you can still use them for derivative data display)
           *
           *
           *  ```
           *  //ready to go
           *  chart.data = [[x1,y1],[x2,y2], ...];
           *  //requires getter for y in metadata, possible getter for x (eg. date)
           *  chart.data = [{ date: Date1, income: 5000 },{ date: Date2, income: 1500 }, ...];
           *  ```
           *
           * @attribute data
           * @type Array
           * @default null
           */
          data: null,
          /**
           * Default line interpolation mode
           * #### Possible values:
           *  - `linear` - piecewise linear segments, as in a polyline.
           *  - `linear-closed` - close the linear segments to form a polygon.
           *  - `step` - alternate between horizontal and vertical segments, as in a step function.
           *  - `step-before` - alternate between vertical and horizontal segments, as in a step function.
           *  - `step-after` - alternate between horizontal and vertical segments, as in a step function.
           *  - `basis` - a B-spline, with control point duplication on the ends.
           *  - `basis-open` - an open B-spline; may not intersect the start or end.
           *  - `basis-closed` - a closed B-spline, as in a loop.
           *  - `bundle` - equivalent to basis, except the tension parameter is used to straighten the spline.
           *  - `cardinal` - a Cardinal spline, with control point duplication on the ends.
           *  - `cardinal-open` - an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
           *  - `cardinal-closed` - a closed Cardinal spline, as in a loop.
           *  - `monotone` - cubic interpolation that preserves monotonicity in y.
           *
           * @attribute interpolation
           * @type String
           * @default 'linear'
           */
          interpolation: 'linear',
          /**
           * Default scale mode for axes
           * #### Possible values:
           *  - `linear` - construct a linear quantitative scale
           *  - `time` - construct a linear time scale
           *  - `pow` - construct a quantitative scale with an exponential transform, setting exponent recommended
           *  - `sqrt` - construct a quantitative scale with a square root transform
           *  - `log` - construct a quantitative scale with an logarithmic transform, requires non 0 x values
           *  - `quantile` - construct a quantitative scale mapping to quantiles, requires setting domain and range
           *  - `quantize` - construct a linear quantitative scale with a discrete output range
           *  - `threshold` - construct a threshold scale with a discrete output range
           *  - `ordinal` - construct an ordinal scale
           *
           *
           *  If you want to add additional settings to your scale turn it to object with property `type` containing selected scale mode.
           *  ```
           *  //scale without extra configuration
           *  scale = 'sqrt';
           *  //scale with configuration
           *  scale = { type: 'pow', exponent: 2 };
           *  ```
           *
           *  See D3.js documentation for [available scale settings](https://github.com/mbostock/d3/wiki/API-Reference#d3scale-scales)
           *
           * @attribute scale
           * @type String or Object
           * @default 'linear'
           */
          scale: 'linear',
          /**
           * The `responsive` attribute if set enables triggering chart size adjustment after resize.
           *
           * @attribute responsive
           * @type boolean
           * @default false
           */
          responsive: {
            value: false,
            reflect: true
          },
          /**
           * The `vertical` attribute if set enables placing legend on the bottom of chart.
           *
           * @attribute vertical
           * @type boolean
           * @default false
           */
          vertical: {
            value: false,
            reflect: true
          },
          /**
           * The `exact` attribute if set disables broadening chart y axes range which is applied for better display of data series close to range extremes.
           *
           * @attribute exact
           * @type boolean
           * @default false
           */
          exact: {
            value: false,
            reflect: true
          },
          /**
           * The `legend` attribute if set enables legend display.
           *
           * @attribute legend
           * @type boolean
           * @default false
           */
          legend: {
            value: false,
            reflect: true
          },
          /**
           * Object with settings for default svg margins override
           * #### Properties:
           *  - `top` - default 10
           *  - `right` - default 60
           *  - `bottom` - default 60
           *  - `left` - default 60
           *
           * @attribute margin
           * @type Object
           * @default null
           */
          margin: null
        },

        //watchers
        observe: {
          metadata: 'prepare',
          scale: 'prepare',
          interpolation: 'prepare',
          margin: 'prepare',
          axes: 'prepare',
          data: 'redraw',
          range: 'redraw',
          exact: 'redraw'
        },

        //lifecycle
        ready: function(){
          var me = this;
          me.uid = ('0000' + (Math.random()*Math.pow(36,4) << 0).toString(36)).slice(-4); //required because of svg clip paths overlapping
          me.margin = me.margin || { top: 10, right: 60, bottom: 60, left: 60};
          me.axes = me.axes || [
            { name: 'xAxis' },
            { name: 'yAxis' }
          ];
          me.metadata = me.metadata || [{ axis: 'yAxis' }];
        },
        domReady: function(){
          this.prepare();
        },

        /**
         * The `prepare()` method recreates chart with updated configuration attributes & size.
         *
         * @method prepare
         * @return {boolean} Returns true if succeeded, otherwise false.
         */
        prepare: function(){
          var me = this,
            bounds = me.$.chart.getBoundingClientRect(),
            svg = d3.select(me.$.paper);

          //clear svg
          svg.selectAll('*').remove();

          //if no config present abandon preparation
          if(!me.axes || !me.metadata){
            return false;
          }

          //if element is not visible abandon preparation
          if(!bounds.width || !bounds.height){
            return false;
          }

          //update svg size to match component
          svg.attr('width', bounds.width);
          svg.attr('height', bounds.height);

          //calculate size of chart draw area
          var margin = me.margin,
            width = bounds.width - margin.left - margin.right,
            height = bounds.height - margin.top - margin.bottom,
            xAxis = me.axes[0];

          //define scale for x axis and y axes and apply configuration
          var _scale, scale, scaleType;
          me.axes.forEach(function(axis, i){
            if(axis.scale){
              scale = (typeof(axis.scale) === 'string') ? { type: axis.scale } : axis.scale;
            }else{
              scale = (typeof(me.scale) === 'string') ? { type: me.scale } : me.scale;
            }
            scaleType = (scale) ? scale.type : 'linear';
            scaleType = (scaleType === 'time' || typeof(d3.scale[scaleType]) === 'function') ? scaleType : 'linear';
            _scale = axis._scale = ((scaleType === 'time') ? d3.time.scale() : d3.scale[scaleType]()).range((i > 0) ? [height, 0] : [0, width]);
            var option;
            for(option in scale){
              if(option !== 'type' && scale.hasOwnProperty(option) && typeof(_scale[option]) === 'function'){
                _scale[option](scale[option]);
              }
            }
          });

          //create focus objects configurations
          var lines = [], line;
          me.metadata.forEach(function(dataset){
            dataset.axis = dataset.axis || 'yAxis';
            var axis = me.axes.filter(function(axis){
                return axis.name === dataset.axis;
              })[0];

            if(axis){
              line = d3.svg.line();
              line.interpolate(dataset.interpolation || axis.interpolation || me.interpolation || 'linear');
              line.x(function(d){
                return xAxis._scale(me.getX(dataset, d));
              });
              line.y(function(d){
                return axis._scale(me.getY(dataset, d));
              });
              lines.push(line);
            }
          });

          //settle axes orientation and ticks
          var axisOrientation,
            _axis, ticks,
            orientation = [
              'bottom',
              'left',
              'right'
            ];
          me.axes.forEach(function(axis, key){
            axisOrientation = orientation[key];
            ticks = axis.ticks;
            if(axisOrientation){
              _axis = axis._axis = d3.svg.axis().scale(axis._scale).orient(axisOrientation);
            }
            if(typeof(ticks) ===  'number'){
              _axis.ticks(ticks);
            }else if(typeof(ticks) === 'object'){
              var option;
              for(option in ticks){
                if(ticks.hasOwnProperty(option) && typeof(_axis[option]) === 'function'){
                  _axis[option](ticks[option]);
                }
              }
            }
          });

          //create svg groups
          var focus = svg.append('g').attr('class', 'focus').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('clip-path', 'url(#cp' + me.uid + ')'),
            axes = svg.append('g').attr('class', 'axes').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'),
            labels = svg.append('g').attr('class', 'labels');

          //append axes and labels to svg
          me.axes.forEach(function(axis, key){
            _axis = axes.append('g');
            if(key === 0){
              _axis.attr('class', 'x axis').attr('transform', 'translate(0,' + height + ')');
              if(axis.label){
                labels.append('text').attr('y', margin.top + height + margin.bottom).attr('x', margin.left + (width / 2)).attr('dy', '-1em').style('text-anchor', 'middle').text(axis.label);
              }
            }else if(key < 3){
              _axis.attr('class', 'y axis ' + axis.name);
              if(key === 2){
                _axis.attr('transform', 'translate(' + width + ' ,0)');
                if(axis.label){
                  labels.append('text').attr('transform', 'rotate(-90)').attr('y', width + margin.right + margin.left).attr('x', 0 - (height/2)).attr('dy', '-1em').style('text-anchor', 'middle').text(axis.label);
                }
              }else if(axis.label){
                labels.append('text').attr('transform', 'rotate(90)').attr('y', 0).attr('x', height/2).attr('dy', '-1em').style('text-anchor', 'middle').text(axis.label);
              }
            }
            _axis.call(axis._axis);
          });

          //append lines to svg
          lines.forEach(function(line, i){
            focus.append('path').attr('class', 'line l' + i);
          });

          //append clipping path to svg
          svg.append('defs').append('clipPath')
            .attr('id', 'cp' + me.uid)
            .append('rect')
            .attr('width', width)
            //height & translate manipulation for proper exact display
            .attr('height', height + 4)
            .attr('transform', 'translate(0 ,-2)');

          //create redraw function
          me.redraw = function(){
            if(me.data){

              //setting domains
              var range, epsilon;
              me.axes.forEach(function(axis, key){
                if(key > 0){
                  if(axis.range && axis.range.length === 2){ //if axis has predefined range
                    axis._scale.domain(axis.range);
                  }else{
                    //find y range for all data in axis
                    range = d3.extent(me.getYs(axis.name));
                    epsilon = (!me.exact) ? (range[1] - range[0]) * 0.02 : 0; //if allowed broaden range for nicer looks
                    axis._scale.domain([range[0] - epsilon, range[1] + epsilon]);
                  }
                }else{
                  if(me.range){ //if user defined specific range
                    axis._scale.domain(me.range);
                  }else{
                    //find x range for all data
                    axis._scale.domain(d3.extent(me.getXs()));
                  }
                }
              });

              //update lines
              lines.forEach(function(line, i){
                focus.select('.line.l' + i).datum(me.data).transition().attr('d', line);
              });
            }

            //update axes
            axes.select('.x.axis').transition().call(xAxis._axis);
            me.axes.forEach(function(axis){
              axes.select('.y.axis.' + axis.name).transition().call(axis._axis);
            });
          };

          //do first redraw
          me.redraw();

          //return success
          return true;
        },

        /**
         * The `redraw()` method redraws the chart with current data.
         *
         * @method redraw
         */
        redraw: function(){
          //placeholder
        },

        //helpers
        getX: function(dataset, d){
          return (dataset.x) ? dataset.x(d) : (isNaN(d[0])) ? this.data.indexOf(d) + 1 : d[0];
        },
        getY: function(dataset, d){
          return (dataset.y) ? dataset.y(d) : d[1];
        },

        /**
         * The `getXs()` method returns all x values from current data.
         *
         * @method getXs
         * @return {Array}
         */
        getXs: function(){
          var me = this;
          return d3.merge(me.metadata.map(function(dataset){
            return me.data.map(function(d){
              return me.getX(dataset, d);
            });
          }));
        },

        /**
         * The `getYs(axisName)` method returns all y values from selected axis.
         *
         * @method getYs
         * @param {String} axisName
         * @return {Array}
         */
        getYs: function(axisName){
          axisName = axisName || this.axes[1].name;
          var me = this,
            datasets = me.metadata.filter(function(dataset){
              return dataset.axis === axisName;
            });
          return d3.merge(datasets.map(function(dataset){
            return me.data.map(function(d){
              return me.getY(dataset, d);
            });
          }));
        }
      });
    })();
  </script>
</polymer-element>
